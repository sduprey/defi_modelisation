# -*- coding: utf-8 -*-
"""tricrypto_multipool_allocation.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/18RTP908hEmmZFBipcglpriGhK6iohO6G
"""

import numpy as np
import matplotlib.pyplot as plt
from scipy.optimize import Bounds, LinearConstraint, minimize
import itertools


def numerical_D(*x, A = 10, epsilon = 0.01, max_iter = 100):
    S = 0
    coins_list = list(x)
    N_COINS = len(coins_list)
    for _x in coins_list:
        S += _x
    if S == 0:
        D = 0
    Dprev = 0
    D = S
    Ann = A * N_COINS**N_COINS
    for _i in range(max_iter):
        D_P = D
        for _x in coins_list:
            D_P = D_P * D / (_x * N_COINS)
        Dprev = D
        D = (Ann * S + D_P * N_COINS) * D / ((Ann - 1) * D + (N_COINS + 1) * D_P)
        if abs(D - Dprev) <= epsilon:
            break
    return D

def compute_invariant(*x,A = 10, D = np.nan):
    nb_coins = len(x)
    sum_coins = np.sum(x)
    product_coins = np.prod(x)
    nn = nb_coins**nb_coins
    return A * nn * sum_coins + D - A * D * nn - D**(nb_coins+1) / (nn * product_coins)

def get_D_after_deposit(*c, deposit = np.nan, A = 10):
    coin_list = list(c)
    # caution : deposit always on the first pair
    coin_list[0] = coin_list[0] + deposit
    return numerical_D(*coin_list, A = A)


def perc_secant(f,a=0.,b=1.,N=10):
    if f(a)*f(b) >= 0:
        print("Secant method fails.")
        return None
    a_n = a
    b_n = b
    for n in range(1,N+1):
        m_n = a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n))
        f_m_n = f(m_n)
        if f(a_n)*f_m_n < 0:
            a_n = a_n
            b_n = m_n
        elif f(b_n)*f_m_n < 0:
            a_n = m_n
            b_n = b_n
        elif f_m_n == 0:
            print("Found exact solution.")
            return m_n
        else:
            print("Secant method fails.")
            return None
    return a_n - f(a_n)*(b_n - a_n)/(f(b_n) - f(a_n))


### Tom's method
def ratio_to_equalize(x_percent, c1, c2, A, lp_pool, lp_strat, c1_prime, c2_prime, A_prime, lp_pool_prime, lp_strat_prime, k0, k0_prime, q_tot):
    alpha = lp_strat * lp_pool_prime * k0 / (k0_prime * lp_pool * lp_strat_prime)
    p1 = alpha * get_D_after_deposit(c1_prime, c2_prime, deposit = q_tot - x_percent * q_tot, A = A_prime)
    p2 = get_D_after_deposit(c1, c2, deposit = x_percent * q_tot, A = A)
    return p1 - p2 + k0 - alpha * k0_prime

def pool_ratio_difference(poolOne, poolPrime, poolOnePercent, poolPrimePercent, q_tot):
    ratioOne = poolOne.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=poolOnePercent * q_tot)
    ratioTwo = poolPrime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=poolPrimePercent * q_tot)
    return ratioOne - ratioTwo

### Tom's method
def compute_pair_ratio_difference(poolOne, poolPrime, x_percent, q_tot):
    lp_strat = poolOne.lp_strat
    k0 = poolOne.k0
    lp_pool = poolOne.lp_pool
    lp_strat_prime = poolPrime.lp_strat
    k0_prime = poolPrime.k0
    lp_pool_prime = poolPrime.lp_pool
    alpha = lp_strat * lp_pool_prime * k0 / (k0_prime * lp_pool * lp_strat_prime)
    p1 = alpha * get_D_after_deposit(c1_prime, c2_prime, deposit=q_tot - x_percent * q_tot, A = A_prime)
    p2 = get_D_after_deposit( c1, c2, deposit = x_percent * q_tot, A = A)
    return p1 - p2 + k0 - alpha * k0_prime

### Tom's method
def pair_ratio_to_nullify(*pools, x_percent=np.nan, q_tot=np.nan):
    pools_list = list(pools)
    poolOne = pools_list[0]
    poolPrime = pools_list[1]
    ratio = compute_pair_ratio_difference(poolOne, poolPrime, x_percent, q_tot)
    return ratio

######## multiple pool optimization
def optimize_ratios(*pools, x_percent=np.nan, q_tot=np.nan):
    pools_list = list(pools)
    pool_quantities = [w*q_tot for w in x_percent]
    assert len(pool_quantities) == len(pools_list)
    total_ratio = 0.
    for pair in set(itertools.combinations(range(len(pools_list)), 2)):
        poolOne = pools_list[pair[0]]
        poolPrime = pools_list[pair[1]]
        poolOnePercent = x_percent[pair[0]]
        poolPrimePercent = x_percent[pair[1]]
        diff_ratio = pool_ratio_difference(poolOne, poolPrime, poolOnePercent, poolPrimePercent, q_tot)
        total_ratio = total_ratio + abs(diff_ratio)
    return total_ratio


def constant_allocation_ratio(*pools, x_percent=np.nan, q_tot=np.nan):
    pools_list = list(pools)
    pool_quantities = [w*q_tot for w in x_percent]
    assert len(pool_quantities) == len(pools_list)
    total_minted = 0
    total_lp_strat = 0
    for me_pool, me_quantity in zip(pools_list, pool_quantities):
        lp_minted_pool_i = me_pool.get_lpminted(deposited_quantity=me_quantity)
        total_minted = total_minted + lp_minted_pool_i
        lp_strat_pool_i = me_pool.get_lpstrat()
        total_lp_strat = total_lp_strat + lp_strat_pool_i
    optimal_allocation = [me_pool.get_lpstrat()/total_lp_strat for me_pool in pools_list]
    current_allocation = [(me_pool.get_lpstrat()+me_pool.get_lpminted(deposited_quantity=me_quantity))/(total_lp_strat+total_minted) for me_pool, me_quantity in zip(pools_list,pool_quantities)]
    optimal_allocation_na = np.array(optimal_allocation)
    current_allocation_na = np.array(current_allocation)
    return np.sum( (optimal_allocation_na - current_allocation_na)* (optimal_allocation_na - current_allocation_na))






class Pool():
    def __init__(self, *c, A = 10, lp_pool= np.nan, k0 = np.nan, lp_strat = np.nan):
        print('careful : the first coin must always be the coin where we will deposit')
        self.coins = list(c)
        self.n_coins = len(self.coins)
        self.A = A
        self.D = self.numerical_D()
        self.lp_pool = lp_pool
        self.k0 = k0
        self.lp_strat = lp_strat

    def get_lpstrat(self,):
        return self.lp_strat

    def get_lpminted(self, deposited_quantity):
        k1 = get_D_after_deposit(*self.coins,deposit=deposited_quantity)
        new_minted = self.lp_pool * (k1-self.k0)/self.k0
        return new_minted

    def get_lpminted_lpstrat_ratio_after_deposit(self, deposited_quantity):
        k1 = get_D_after_deposit(*self.coins,deposit=deposited_quantity)
        new_minted = self.lp_pool * (k1-self.k0)/self.k0
        return new_minted/self.lp_strat

    def numerical_D(self, A = 10, epsilon = 0.01, max_iter = 100):
        S = 0
        coins_list = self.coins.copy()
        N_COINS = len(coins_list)
        for _x in coins_list:
            S += _x
        if S == 0:
            D = 0
        Dprev = 0
        D = S
        Ann = A * N_COINS**N_COINS
        for _i in range(max_iter):
            D_P = D
            for _x in coins_list:
                D_P = D_P * D / (_x * N_COINS)  # +1 is to prevent /0

            Dprev = D
            D = (Ann * S + D_P * N_COINS) * D / ((Ann - 1) * D + (N_COINS + 1) * D_P)
            if abs(D - Dprev) <= epsilon:
                break
        return D

######## pool pair optimization
# pool1
c1 = 20
c2 = 200
A = 10
k0 = numerical_D(c1,c2,A=A)
lp_pool = k0
lp_strat = 200
print(f'stable swap pool1: {k0}')
print(f'Lps number  pool1: {lp_pool}')
print(f'Lps strat of pool1: {lp_strat}')

pool = Pool(c1,c2,A=A, lp_pool= lp_pool,k0 = k0,lp_strat = lp_strat)

# pool2
c1_prime = 200
c2_prime = 200
A_prime = 10
k0_prime = numerical_D(c1_prime,c2_prime,A = A_prime)

lp_pool_prime = k0_prime
lp_strat_prime = 200

print(f'stable swap pool2: {k0_prime}')
print(f'Lps number  pool2: {lp_pool_prime}')
print(f'Lps strat of pool2: {lp_strat_prime}')

poolprime = Pool(c1_prime, c2_prime, A=A_prime, lp_pool= lp_pool_prime, k0 = k0_prime, lp_strat = lp_strat_prime)

############# plotting the quantity to find root
# deposit amount
q_tot = 100
x_plot = [i/100. for i in range(1,99)]
y_plot = []
for i in x_plot:
    y_plot.append(ratio_to_equalize(i, c1, c2, A, lp_pool, lp_strat, c1_prime, c2_prime, A_prime, lp_pool_prime, lp_strat_prime, k0, k0_prime,q_tot))
plt.plot(x_plot, y_plot)
plt.grid()

#########################
#########################
######################### Tom's method but with a simple dichotomy
#########################
#########################
print('optimization')

func_opti = lambda x : pair_ratio_to_nullify(pool, poolprime, x_percent = x, q_tot = q_tot)
from scipy import optimize
xstart = q_tot/2
xoptim_newton = optimize.newton(func_opti,xstart)
print(xoptim_newton)
xoptim_secant = perc_secant(func_opti, N=2)
print('same value found as Tom')
print(xoptim_secant)

xoptim_secant_bis = optimize.root_scalar(func_opti, x0=0.,x1=1.,method='secant')
print(xoptim_secant_bis)

print('to keep the target ratios, those should be equal')
print('before optimization')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=0.5 * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=0.5 * q_tot))

print('to keep the target ratios, those should be equal')
print('after optimization')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=xoptim_secant * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=(1. - xoptim_secant) * q_tot))

#### same value found as Tom
print('two pool optim done with simple dichotomy allocation')
print(xoptim_secant)
print(xoptim_newton)

"""$\min_{\sum_{i} x_i = 1} \left[  \sum_{pair i,j}  \left| \frac{lpminted_{pool i(x_i)}}{lpstrat_{pool i}} - \frac{lpminted_{pool j(x_j)}}{lpstrat_{pool j}} \right|\right]$

"""

##########
##########
########## Testing on simple two pools that the N methodology gives us the same thing
##########
##########
N=2
func_multi_opti = lambda x : optimize_ratios(pool, poolprime, x_percent = x, q_tot = q_tot)
w0 = np.ones([N]) / N
const_sum = LinearConstraint(np.ones([1, N]), [1], [1])
low_bound = 0.
up_bound = 1.
const_ind = Bounds(low_bound * np.ones([N]), up_bound * np.ones([N]))
result_two = minimize(
    func_multi_opti,
    w0,
    method='SLSQP',
    constraints=[const_sum],
    bounds=const_ind
)
##@ we find back 46.29% on pool and 100-x on poolPrime
print(result_two)

print('before optimization')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity= 0.5 * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity= 0.5 * q_tot))

print('to keep the target ratios, those should be equal')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_two.x[0] * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_two.x[1] * q_tot))

#### same value found as Tom again
print('####optimization two pools with N pool methodology allocation')
print(result_two.x)

########################################################################
####################################
#################################### retesting the same optimization with the new methodology
########################################################################
########################################################################
########################################################################


N=2
func_multi_opti = lambda x : constant_allocation_ratio(pool, poolprime, x_percent = x, q_tot = q_tot)
w0 = np.ones([N]) / N
const_sum = LinearConstraint(np.ones([1, N]), [1], [1])
low_bound = 0.
up_bound = 1.
const_ind = Bounds(low_bound * np.ones([N]), up_bound * np.ones([N]))
result_two = minimize(
    func_multi_opti,
    w0,
    method='SLSQP',
    constraints=[const_sum],
    bounds=const_ind
)
##@ we find back 46.29% on pool and 100-x on poolPrime
print(result_two)

print('before optimization')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity= 0.5 * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity= 0.5 * q_tot))

print('to keep the target ratios, those should be equal')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_two.x[0] * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_two.x[1] * q_tot))

#### same value found as Tom again
print('####optimization two pools with N pool new methodology allocation')
print(result_two.x)


"""$\min_{\sum_{i} x_i = 1} \left[  \sum_{pair i,j}  \left| \frac{lpminted_{pool i(x_i)}}{lpstrat_{pool i}} - \frac{lpminted_{pool j(x_j)}}{lpstrat_{pool j}} \right|\right]$

"""

# pool3 three currencies
c1_primeprime = 220
c2_primeprime = 180
c3_primeprime = 190
A_primeprime = 10
k0_primeprime = numerical_D(c1_primeprime,c2_primeprime,c3_primeprime,A = A_primeprime)

lp_pool_primeprime = k0_primeprime
lp_strat_primeprime = 200

print(f'stable swap pool3: {k0_primeprime}')
print(f'Lps number  pool3: {lp_pool_primeprime}')
print(f'Lps strat of pool3: {lp_strat_primeprime}')
poolprimeprime = Pool(c1_primeprime, c2_primeprime, c3_primeprime, A=A_primeprime, lp_pool= lp_pool_primeprime, k0 = k0_primeprime, lp_strat = lp_strat_primeprime)

# # pool3 two currencies
# c1_primeprime = 220
# c2_primeprime = 180
# A_primeprime = 10
# k0_primeprime = numerical_D(c1_primeprime,c2_primeprime,A = A_primeprime)
#
# lp_pool_primeprime = k0_primeprime
# lp_strat_primeprime = 200
#
# print(f'stable swap pool3: {k0_primeprime}')
# print(f'Lps number  pool3: {lp_pool_primeprime}')
# print(f'Lps strat of pool3: {lp_strat_primeprime}')
#
# poolprimeprime = Pool(c1_primeprime, c2_primeprime, A=A_primeprime, lp_pool= lp_pool_primeprime, k0 = k0_primeprime, lp_strat = lp_strat_primeprime)

############################################################
###########################
########################### three pools optimization
###########################
############################################################
N=3
func_multi_opti = lambda x : optimize_ratios(pool, poolprime, poolprimeprime, x_percent = x, q_tot = q_tot)
#q_tot = 100
#toto = func_opti(q_tot/2.)
#print(toto)

method = 'SLSQP'

w0 = np.ones([N]) / N
const_sum = LinearConstraint(np.ones([1, N]), [1], [1])
low_bound = 0.
up_bound = 1.
const_ind = Bounds(low_bound * np.ones([N]), up_bound * np.ones([N]))
result_three = minimize(
    func_multi_opti,
    w0,
    method=method,
    constraints=[const_sum],
    bounds=const_ind
)

print('before optimization')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[0] * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[1] * q_tot))
print(poolprimeprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[2] * q_tot))

print('after optimization, to keep the target ratios, those should be equal')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[0] * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[1] * q_tot))
print(poolprimeprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[2] * q_tot))

print('############ optimization three pool allocation')
print(result_three.x)
print('############ three pools optimization done')

############################################################
###########################
########################### three pools optimization with the new methodology
###########################
############################################################

N=3
func_multi_opti = lambda x : constant_allocation_ratio(pool, poolprime, poolprimeprime, x_percent = x, q_tot = q_tot)
#q_tot = 100
#toto = func_opti(q_tot/2.)
#print(toto)

method = 'SLSQP'

w0 = np.ones([N]) / N
const_sum = LinearConstraint(np.ones([1, N]), [1], [1])
low_bound = 0.
up_bound = 1.
const_ind = Bounds(low_bound * np.ones([N]), up_bound * np.ones([N]))
result_three = minimize(
    func_multi_opti,
    w0,
    method=method,
    constraints=[const_sum],
    bounds=const_ind
)

print('before optimization')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[0] * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[1] * q_tot))
print(poolprimeprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[2] * q_tot))

print('after optimization, to keep the target ratios, those should be equal')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[0] * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[1] * q_tot))
print(poolprimeprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[2] * q_tot))

print('############ optimization three pool allocation new methodology')
print(result_three.x)
print('############ three pools optimization done new methodology')

########################################################
########################################################
##################
################## simplified version
##################
########################################################
########################################################
def get_matrix_A(*pools):
    pools_list = list(pools)
    nb_pools = len(pools_list)
    lis = np.array([me_pool.get_lpstrat() for me_pool in pools_list])
    L = np.sum(lis)
    final_matrix = np.zeros((nb_pools, nb_pools))
    for me_pool_index in range(nb_pools):
        li = lis[me_pool_index]
        ai = np.array([-li/(L*L)]*nb_pools)
        ai[me_pool_index] = ai[me_pool_index] + 1./L
        ai = ai.reshape(nb_pools, 1)
        add_matrix = ai @ ai.T
        final_matrix = final_matrix + add_matrix
    return final_matrix

def linearized_optimization(*pools, x_percent=np.nan, q_tot=np.nan):
    pools_list = list(pools)
    a = get_matrix_A(*pools)
    f = [me_pool.get_lpminted(me_percent * q_tot) for me_pool, me_percent in zip(pools_list,x_percent)]
    f = np.array(f)
    return f.T @ a @ f

N=3
func_multi_opti = lambda x : linearized_optimization(pool, poolprime, poolprimeprime, x_percent = x, q_tot = q_tot)
#q_tot = 100
#toto = func_opti(q_tot/2.)
#print(toto)

method = 'SLSQP'
w0 = np.ones([N]) / N
const_sum = LinearConstraint(np.ones([1, N]), [1], [1])
low_bound = 0.
up_bound = 1.
const_ind = Bounds(low_bound * np.ones([N]), up_bound * np.ones([N]))
result_three = minimize(
    func_multi_opti,
    w0,
    method=method,
    constraints=[const_sum],
    bounds=const_ind
)

print('before optimization')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[0] * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[1] * q_tot))
print(poolprimeprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[2] * q_tot))

print('after optimization, to keep the target ratios, those should be equal')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[0] * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[1] * q_tot))
print(poolprimeprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[2] * q_tot))

print('############ optimization three pool allocation new methodology')
print(result_three.x)
print('############ three pools optimization done new methodology')

####################################################################################
####################################################################################
##################
################## optimization using gradient descent
##################
####################################################################################
####################################################################################
####################################################################################


N=3
func_multi_opti = lambda x : linearized_optimization(pool, poolprime, poolprimeprime, x_percent = x, q_tot = q_tot)
#q_tot = 100
#toto = func_opti(q_tot/2.)
#print(toto)

method = 'SLSQP'
w0 = np.ones([N]) / N
result_three = minimize(
    func_multi_opti,
    w0,
    method=method,
)

print('before optimization')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[0] * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[1] * q_tot))
print(poolprimeprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=w0[2] * q_tot))

print('after optimization, to keep the target ratios, those should be equal')
print(pool.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[0] * q_tot))
print(poolprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[1] * q_tot))
print(poolprimeprime.get_lpminted_lpstrat_ratio_after_deposit(deposited_quantity=result_three.x[2] * q_tot))

print('############ optimization three pool allocation new methodology without constraints')
print(result_three.x)
print('############ three pools optimization done new methodology without constraints')
###########
###########
###########
###########
###########
###########
###########
###########

def compute_lp_minted(*pools, x_percent=np.nan, q_tot=np.nan, epsilon = 1e-6):
    pools_list = list(pools)
    f = [me_pool.get_lpminted(me_percent*q_tot) for me_pool, me_percent in zip(pools_list,x_percent)]
    f = np.array(f)
    return f

def compute_gradient_lp_minted(*pools, x_percent=np.nan, q_tot=np.nan, epsilon = 1e-6):
    pools_list = list(pools)
    gf = [me_pool.get_lpminted(((me_percent+epsilon) * q_tot) -me_pool.get_lpminted((me_percent-epsilon) * q_tot))/(2.*epsilon)  for me_pool, me_percent in zip(pools_list,x_percent)]
    gf = np.array(gf)
    return gf

def compute_quadratic_gradient(*pools, x_percent=np.nan, q_tot=np.nan, epsilon = 1e-6):
    a = get_matrix_A(*pools)
    gf = compute_gradient_lp_minted(*pools, x_percent = x_percent, q_tot = q_tot, epsilon = epsilon)
    f = compute_lp_minted(*pools, x_percent = x_percent, q_tot = q_tot, epsilon = epsilon)
    func_grad = ((2 * a) @ f) * gf
    return func_grad

def gradient_descent(pool, poolprime, poolprimeprime, q_tot=np.nan, start=np.nan, learn_rate = 1e-6, n_iter=5, tolerance=1e-10):
    vector = start
    for _ in range(n_iter):
        diff = -learn_rate *compute_quadratic_gradient(pool, poolprime, poolprimeprime, x_percent = vector, q_tot = q_tot)
        if np.all(np.abs(diff) <= tolerance):
            break
        vector += diff
        print('functional')
        print(linearized_optimization(pool, poolprime, poolprimeprime, x_percent=vector, q_tot=q_tot))
    return vector

print('gradient descent')
solution = gradient_descent(pool, poolprime, poolprimeprime, start = w0, q_tot = q_tot)
print(solution)
func_value = linearized_optimization(pool, poolprime, poolprimeprime, x_percent = solution, q_tot = q_tot)
print(func_value)


solution = gradient_descent(func_multi_opti, [0.3333,0.3333,0.3333], 1e-2)