# -*- coding: utf-8 -*-
"""AaveOptimizationAnalytical.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1IZLYkH6OOM6I5k_ENvesC6uA0cyB-pfX
"""

import numpy as np

dai_sapy, dai_sapr, dai_bapy, dai_bapr, dai_Lt, dai_Bt = 2.17, 2.97, 3.51, 0.37, 1.1*10e9, 762.7*10e6
usdt_sapy, usdt_sapr, usdt_bapy, usdt_bapr, usdt_Lt, usdt_Bt = 1.29, 2.78, 2.70, 0.45, 282.24*10e6,150.45*10e6
usdc_sapy, usdc_sapr, usdc_bapy, usdc_bapr, usdc_Lt, usdc_Bt = 1.47, 2.60, 2.89, 0.4, 1.36*10e9,775.97*10e6

dai_U = dai_Bt/dai_Lt
usdt_U = usdt_Bt/usdt_Lt
usdc_U = usdc_Bt/usdc_Lt

print(f'Dai total liquidity :{dai_Lt} total borrow :{dai_Bt} utilization ratio {dai_U}')
print(f'USDT total liquidity :{usdt_Lt} total borrow :{usdt_Bt} utilization ratio {usdt_U}')
print(f'USDC total liquidity :{usdc_Lt} total borrow :{usdc_Bt} utilization ratio {usdc_U}')

print(f'Dai SAPY {dai_sapy} U*BAPY {dai_bapy *dai_U }')
print(f'USDC SAPY {usdc_sapy} U*BAPY {usdc_bapy *usdc_U }')
print(f'USDT SAPY {usdt_sapy} U*BAPY {usdt_bapy *usdt_U }')

dai_cte_sAPR = dai_sapr * dai_Lt
dai_cte_bAPR = dai_bapr * dai_Bt
print(f'dai_sapr {dai_cte_sAPR / dai_Lt}')
print(f'dai_bapr {dai_cte_bAPR / dai_Bt}')

usdc_cte_sAPR = usdc_sapr * usdc_Lt
usdc_cte_bAPR = usdc_bapr * usdc_Bt
print(f'usdc_sapr {usdc_cte_sAPR / usdc_Lt}')
print(f'usdc_bapr {usdc_cte_bAPR / usdc_Bt}')

usdt_cte_sAPR = usdt_sapr * usdt_Lt
usdt_cte_bAPR = usdt_bapr * usdt_Bt
print(f'usdt_sapr {usdt_cte_sAPR / usdt_Lt}')
print(f'usdt_bapr {usdt_cte_bAPR / usdt_Bt}')


def fromAPRToAPY(apr,nb_second_per_year = 3.154e+7):
  apy = (1+(apr/nb_second_per_year))**(nb_second_per_year)-1
  return apy

def pool_totalAPY( X = np.nan, AUM = np.nan, Lt=np.nan , Bt = np.nan, cte_sAPR = np.nan, cte_bAPR = np.nan, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6):
  bAPR = cte_bAPR/Bt
  sAPR = cte_sAPR/(Lt + X*AUM)
  biAPY = fromAPRToAPY(bAPR)
  siAPY = fromAPRToAPY(sAPR)
  U = Bt/(Lt + X*AUM)
  if U<=U_optimal:
    Rb = base + slope1*(U/U_optimal)
  else :
    Rb = base + slope1 + slope2*((U-U_optimal)/(1-U_optimal))
  Rs =U*Rb
  return Rs - Rb + biAPY + siAPY

dai_APY = pool_totalAPY(X = 0., AUM =0., Lt=dai_Lt , Bt = dai_Bt, cte_sAPR = dai_cte_sAPR, cte_bAPR = dai_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)
print(dai_APY)

usdc_APY = pool_totalAPY(X = 0., AUM =0., Lt=usdc_Lt , Bt = usdc_Bt, cte_sAPR = usdc_cte_sAPR, cte_bAPR = usdc_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)
print(usdc_APY)

usdt_APY = pool_totalAPY(X = 0., AUM =0., Lt=usdt_Lt , Bt = usdt_Bt, cte_sAPR = usdt_cte_sAPR, cte_bAPR = usdt_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)
print(dai_APY)

dai_APY = pool_totalAPY(X = 0.5, AUM =1. * 10e6, Lt=dai_Lt , Bt = dai_Bt, cte_sAPR = dai_cte_sAPR, cte_bAPR = dai_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)
print(dai_APY)
usdc_APY = pool_totalAPY(X = 0.5, AUM =1. * 10e6, Lt=usdc_Lt , Bt = usdc_Bt, cte_sAPR = usdc_cte_sAPR, cte_bAPR = usdc_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)
print(usdc_APY)
usdt_APY = pool_totalAPY(X = 0.5, AUM =1. * 10e6, Lt=usdt_Lt , Bt = usdt_Bt, cte_sAPR = usdt_cte_sAPR, cte_bAPR = usdt_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)
print(dai_APY)

def get_simplex_pool_vector(AUM = np.nan, Lt=np.nan , Bt = np.nan, cte_sAPR = np.nan, cte_bAPR = np.nan, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6):
  bAPR = cte_bAPR/Bt
  sAPR = (cte_sAPR/Lt)
  c0 = bAPR + sAPR
  c1 = -1 * sAPR * (AUM/Lt)
  return c0, c1

from scipy.optimize import Bounds, LinearConstraint, minimize
import pandas as pd
linear_results = {}
AUM  = 10**6

dai_pool_c0, dai_pool_c1  = get_simplex_pool_vector(AUM = AUM, Lt=dai_Lt, Bt=dai_Bt, cte_sAPR = dai_cte_sAPR, cte_bAPR = dai_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)
usdc_pool_c0, usdc_pool_c1 = get_simplex_pool_vector(AUM = AUM, Lt=usdc_Lt, Bt=usdc_Bt, cte_sAPR = usdc_cte_sAPR, cte_bAPR = usdc_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)
usdt_pool_c0,  usdt_pool_c1 = get_simplex_pool_vector(AUM = AUM, Lt=usdt_Lt, Bt=usdt_Bt, cte_sAPR = usdt_cte_sAPR, cte_bAPR = usdt_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)
print(f'dai_pool_c0 {dai_pool_c0},dai_pool_c1 {dai_pool_c1}')
print(f'usdc_pool_c0 {usdc_pool_c0},usdc_pool_c1 {usdc_pool_c1}')
print(f'usdt_pool_c0 {usdt_pool_c0},usdt_pool_c1 {usdt_pool_c1}')

def compute_gradient(X = np.nan, dai_pool_c0 = np.nan, dai_pool_c1 = np.nan, usdc_pool_c0 = np.nan, usdc_pool_c1 = np.nan, usdt_pool_c0 = np.nan,  usdt_pool_c1 = np.nan):
  return np.array([-dai_pool_c0 - 2*dai_pool_c1*X[0], -usdc_pool_c0 - 2*usdc_pool_c1*X[1], -usdt_pool_c0 - 2*usdt_pool_c1*X[2]])
import numpy as np
analytical_solution = np.array([-dai_pool_c0 / (2. *dai_pool_c1 ), -usdc_pool_c0 / (2. *usdc_pool_c1 ), -usdt_pool_c0 / (2.*usdt_pool_c1 )])
gd =compute_gradient(X = analytical_solution,dai_pool_c0 = dai_pool_c0, dai_pool_c1 = dai_pool_c1, usdc_pool_c0 = usdc_pool_c0, usdc_pool_c1 = usdc_pool_c1, usdt_pool_c0 = usdt_pool_c0,  usdt_pool_c1 = usdt_pool_c1)
print('analytical solution')
print(analytical_solution)
print(gd)

print('dai_pool_c0')
print(dai_pool_c0)

print('usdc_pool_c0')
print(usdc_pool_c0)

print('usdt_pool_c0')
print(usdt_pool_c0)

print('usdt_pool_c1')
print(usdt_pool_c1)

print('dai_pool_c1')
print(dai_pool_c1)

print('usdc_pool_c1')
print(usdc_pool_c1)

dai_cc=dai_pool_c0 / (2. *dai_pool_c1 )
print('dai_cc=dai_pool_c0 / (2. *dai_pool_c1 )')
print(dai_cc)
usdc_cc=usdc_pool_c0 / (2. *usdc_pool_c1 )
print('usdc_cc=usdc_pool_c0 / (2. *usdc_pool_c1 )')
print(usdc_cc)
usdt_cc=usdt_pool_c0 / (2.*usdt_pool_c1 )
print('usdt_cc=usdt_pool_c0 / (2.*usdt_pool_c1 )')
print(usdt_cc)

glambda = (-1-dai_cc-usdc_cc-usdt_cc)/(1/(2.*dai_pool_c1 )+1/(2. *usdc_pool_c1 )+1/(2. *usdt_pool_c1 ))

x0sol =-(glambda+dai_pool_c0) / (2. *dai_pool_c1 )
x1sol =-(glambda+usdc_pool_c0) / (2. *usdc_pool_c1 )
x2sol =-(glambda+usdt_pool_c0) / (2.*usdt_pool_c1 )

print('constrained analytical solution')
print([x0sol,x1sol,x2sol])

x =np.array([x0sol,x1sol,x2sol])

(x - min(x))/sum(x - min(x))

import numpy as np
def linear_pool_APRonly_totalAPY( X = np.nan, AUM = np.nan, Lt=np.nan , Bt = np.nan, cte_sAPR = np.nan, cte_bAPR = np.nan, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6):
  U = (Bt/Lt)*(1 -  (X*AUM)/Lt)
  assert(U<=U_optimal)

  bAPR = cte_bAPR/Bt
  sAPR = (cte_sAPR/Lt) * (1 -  (X*AUM)/Lt)
  return bAPR + sAPR


from scipy.optimize import Bounds, LinearConstraint, minimize
import pandas as pd
linear_results = {}

AUM  = 10**6
print(f'optimizing for AUM {AUM}')
dai_pool = lambda x : linear_pool_APRonly_totalAPY(X = x, AUM = AUM, Lt=dai_Lt, Bt=dai_Bt, cte_sAPR = dai_cte_sAPR, cte_bAPR = dai_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)
usdc_pool = lambda x : linear_pool_APRonly_totalAPY(X = x, AUM = AUM, Lt=usdc_Lt, Bt=usdc_Bt, cte_sAPR = usdc_cte_sAPR, cte_bAPR = usdc_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)
usdt_pool = lambda x : linear_pool_APRonly_totalAPY(X = x, AUM = AUM, Lt=usdt_Lt, Bt=usdt_Bt, cte_sAPR = usdt_cte_sAPR, cte_bAPR = usdt_cte_bAPR, U_optimal = 0.9, base = 0, slope1 = 0.04, slope2=0.6)

def optimize(x):
  my_objective = -(x[0] * dai_pool(x[0]) + x[1] * usdc_pool(x[1]) + x[2] * usdt_pool(x[2]))
  return my_objective
print(optimize((0.5,0.1,0.4)))
N = 3
w0 = np.ones([N]) / N

const_sum = LinearConstraint(np.ones([1, N]), [1], [1])
low_bound = 0.
up_bound = 1.

const_ind = Bounds(low_bound * np.ones([N]), up_bound * np.ones([N]))

result_final = minimize(
    optimize,
    w0,
    method='SLSQP',
    constraints=[const_sum],
    bounds=const_ind
)

if result_final.success :
  print(result_final.x)